# Arquivo de configuração do servidor nats, stream e consumers.
# Localização default /etc/nats.conf

[debug]
# exibição de mensagens no console
console = true

[nats]
endpoint = "127.0.0.1:6379"   #"127.0.0.1:8379"
pool-size = 100
dial-timeout = 10

# Se 'false', desliga o envio de dados de todos os callbacks para o cliente, provenientes do redis.
# Caso a linha de configuração abaixo inexistir, o valor padrão é 'true', permitindo o callback.
callback-polling = false  #true

# chave de acesso para manter no redis o status de cada cliente conectado.
# key é a composição da chave da entidade com seu ID. Ex: "driver:45"
# os termos entre colchetes serão substituídos pelo sistema
status-key = "wss:{[key]}:st"

# estão previstas até 3 chaves, finalizando com "hi", "nm" e "lo"
# para serem priorizadas pelo servidor no envio ao websocket.
# Os termos entre colchetes serão substituídos pelo sistema
reading-keys = ["wss:{[key]}:hi","wss:{[key]}:nm","wss:{[key]}:lo"]

# redirecionamento para recuperar mais informação do redis após a leitura
# das chaves "reading-keys", caso o payload delas tenha indicação para tal.
collapsible-key = "wss:{[key]}:[cat]"

# quantidade de milissegundos antes de levantar timeout, na espera
# de dados a serem enviados ao cliente, nas streams no redis
wait-dispatcher = 10000

# intervalo de espera em caso de erro na comunicação com o redis, em milissegundos
wait-error = 2000

[logs]
# serviço http para enviar logs.
url-log = "http://localhost/ws/url/log"
# subdiretório para gravar o log em arquivo
filepath-log = "c:/go_develop/wsconnect/applog/wsconnect"   #/applog/wsconnect
# ligar o log em arquivo.  Default "false".
active-file-log = true
# ligar o log de conexão do cliente.  Default "false".
connection-file-log = false
# ligar o log em arquivo para todos os "routes".  Default "false".
route-file-log = false
# ligar o log em arquivo para todos os "callbacks".  Default "false".
callback-file-log = false
# ligar o tracing.  Default "false".  Ainda não implementado
tracing = false

[auth]
jwt-secret = "bSh4cGORqEt8bAWYe3Dk"

[listener]
# porta de conexão com o websocket
ws-port = "80"

# endpoint para ligar/desligar impressão de debug no console
# formato: http://localhost/ws/console?debug=true/false
url-console = "/ws/console/"

# endpoint para ligar/desligar gravação de log em arquivo
# formato: http://localhost/ws/filelog?active=true/false&r=true/false&c=true/false
#          active - liga ou desliga todo o log via arquivo
#          r - liga ou desliga o log dos routes
#          c - liga ou desliga o log dos callbacks
# os parâmetros da 'querystring' são opcionais, os não informados
# permanecerão no mesmo estado em que se encontram.
# os valores padrão estão na seção [logs] deste arquivo, nos respectivos parâmetros:
# active-file-log, route-file-log e callback-file-log
url-file-log = "/ws/filelog/"

# endpoint de entrada do cliente do websocket, passando o JWT correspondente
# formato: ws://localhost/ws/<jwt aqui>
url-ws = "/ws/:jwt"

[entity.driver]
# serviços http chamados nos momentos de conexão e desconexão dos clientes do tipo "driver"
url-connect = "http://localhost/ws/url/authorize"
url-disconnect = "http://localhost/ws/url/disconnect"

[entity.passenger]
# serviços http chamados nos momentos de conexão e desconexão dos clientes do tipo "passenger"
url-connect = "http://localhost/ws/url/authorize"
url-disconnect = "http://localhost/ws/url/disconnect"

# eventos de entrada (websocket -> backend)
# todos tem o formato "route.<nome>"
[route.position]
# tipos de clientes permitidos neste route
entities = ["driver", "passenger"]
# endpoint http chamado por este servidor quando o cliente
# envia uma mensagem json contendo wsc_route="position"
url = "http://localhost/ws/urlget/posicao"
# verbo usado para chamar o endpoint mencionado acima
http-method = "GET"   #POST, GET
# indicação de como os dados serão passados ao endpoint
payload-type = "query-parameters" #json, query-parameters
timeout = 500
retries = 3
# indica se o retorno do endpoint será redirecionado ao cliente, via websocket
reply = "response"  #none, response
# quando preenchido, o conteúdo abaixo será enviado ao cliente como se
# o endpoint acima tivesse sido chamado, caso "reply = response".
mock-reply = ""

# ligar o log do payload das mensagens recebidas do cliente
# e enviadas para o backend.  Default "false".
# O flag active-file-log deve estar ligado para que funcione.
log-file-payload = false

# Indicar que o log de monitoramento deve ser registrado.
# O flag active-file-log deve estar ligado para que funcione.
# O valor default é "false".
log-mon-only  = true

# Atributos genéricos de até 36 posições (ex: id da solicitação), opcionais.
# Não tem efeito se o atributo não for encontrado no payload.
# Funciona em conjunto com "log-mon-only = true"
log-mon-attr1 = "bandeira"
log-mon-attr2 = "campo1"

# atributos recebidos do JWT no momento da conexão do cliente.
# os que estiverem presentes serão passados ao endpoint (url) no header da chamada.
# configuração opcional
jwt-claims = ["App-Key", "id", "entity"]

# evento de saída (backend -> websocket)
[callback.available-rides]
# ligar o log do payload das mensagens enviadas ao cliente,
# provenientes do backend.  Default "false".
# O flag active-file-log deve estar ligado para que funcione.
log-file-payload = false
